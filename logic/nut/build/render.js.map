{"version":3,"sources":["../src/render.js"],"names":["render","req","res","routes","document","assets","customRenderer","rest","Doc","DefaultDocument","context","path","match","initialProps","status","redirectTo","redirect","originalUrl","replace","renderPage","fn","modPage","defaultRenderer","element","html","ReactDOMServer","renderToString","renderer","asyncOrSyncRender","url","Nut","utils","isPromise","renderedContent","helmet","Helmet","renderStatic","reactRouterMatch","getInitialProps","docProps","doc","renderToStaticMarkup","Page","props"],"mappings":"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","sourcesContent":["import React from \"react\";\nimport { matchPath, StaticRouter } from \"react-router-dom\";\nimport { DefaultDocument } from \"./default-document\";\nimport ReactDOMServer from \"react-dom/server\";\nimport Helmet from \"react-helmet\";\nimport { Nut } from \"./nut\";\nimport * as utils from \"./utils\";\nimport { loadInitialProps } from \"./load-initial-props\";\n\n/**\n * rendering function on server\n *\n * match route config by req.url and find relative page Component\n * call Component.getInitProps to get page init data, so we can render\n * page to html. render Document Compoent wrapping page's html to html\n * and send it to client\n */\nexport async function render({\n  req,\n  res,\n  routes,\n  document,\n  assets,\n  customRenderer,\n  ...rest\n}) {\n  const Doc = document || DefaultDocument;\n  const context = {};\n  const { match, initialProps } = await loadInitialProps(routes, req.path, {\n    req,\n    res,\n    ...rest\n  });\n\n  if (!match) {\n    res.status(404);\n    return;\n  }\n\n  if (match.path === \"**\") {\n    res.status(404);\n  } else if (match && match.redirectTo && match.path) {\n    res.redirect(301, req.originalUrl.replace(match.path, match.redirectTo));\n    return;\n  }\n\n  const renderPage = async (fn = modPage) => {\n    // By default, we keep ReactDOMServer synchronous renderToString function\n    const defaultRenderer = element => ({\n      html: ReactDOMServer.renderToString(element)\n    });\n    const renderer = customRenderer || defaultRenderer;\n    const asyncOrSyncRender = renderer(\n      <StaticRouter location={req.url} context={context}>\n        {fn(Nut)({ routes, initialProps })}\n      </StaticRouter>\n    );\n\n    const renderedContent = utils.isPromise(asyncOrSyncRender)\n      ? await asyncOrSyncRender\n      : asyncOrSyncRender;\n    const helmet = Helmet.renderStatic();\n\n    return { helmet, ...renderedContent };\n  };\n\n  const reactRouterMatch = matchPath(req.url, match);\n\n  const { html, ...docProps } = await Doc.getInitialProps({\n    req,\n    res,\n    assets,\n    renderPage,\n    initialProps,\n    match: reactRouterMatch,\n    helmet: Helmet.renderStatic(),\n    ...rest\n  });\n\n  const doc = ReactDOMServer.renderToStaticMarkup(<Doc {...docProps} />);\n  return `<!doctype html>${doc.replace(\n    \"DO_NOT_DELETE_THIS_YOU_WILL_BREAK_YOUR_APP\",\n    html\n  )}`;\n}\n\nfunction modPage(Page) {\n  return props => <Page {...props} />;\n}\n"],"file":"render.js"}